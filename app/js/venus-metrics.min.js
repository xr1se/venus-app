var Venus =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/DataBinding.js":
/*!****************************!*\
  !*** ./src/DataBinding.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DataBinding = exports.DataBinding = function () {
	function DataBinding(element, elementProperty, metric, metricProperty) {
		_classCallCheck(this, DataBinding);

		this.element = element;
		this.elementProperty = elementProperty;
		this.metric = metric;
		this.metricProperty = metricProperty;
		this.update();
		var ref = this;
		this.metric.addOnChangeCallback(function (metric) {
			ref.update();
		});
	}

	_createClass(DataBinding, [{
		key: "update",
		value: function update() {
			this.element[this.elementProperty] = this.metric[this.metricProperty];
		}
	}]);

	return DataBinding;
}();

/***/ }),

/***/ "./src/Metric.js":
/*!***********************!*\
  !*** ./src/Metric.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.defaultFormatter = defaultFormatter;
exports.numericFormatter = numericFormatter;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Metric = exports.Metric = function () {
	function Metric(key, description, unit, formatter) {
		_classCallCheck(this, Metric);

		this.key = key;
		this.description = description;
		this.unit = unit;
		this.formatter = formatter === undefined ? defaultFormatter() : formatter;
		this._rawValue = undefined;
		this.callbacks = [];
	}

	/* Gets the formatted value of the metric */


	_createClass(Metric, [{
		key: 'addOnChangeCallback',
		value: function addOnChangeCallback(callback) {
			this.callbacks.push(callback);
		}
	}, {
		key: 'value',
		get: function get() {
			return this.formatter(this);
		}

		/* Gets the raw value of the metric */

	}, {
		key: 'rawValue',
		get: function get() {
			return this._rawValue;
		}

		/* Sets the raw value of the metric
   * This will also fire any registered callbacks 
   */
		,
		set: function set(rawValue) {
			var _this = this;

			this._rawValue = rawValue;
			this.callbacks.forEach(function (callback) {
				callback(_this);
			});
		}
	}]);

	return Metric;
}();

function defaultFormatter() {
	var defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '--';

	return function (metric) {
		if (metric.rawValue === undefined || metric.rawValue === null) {
			return defaultValue;
		}
		return metric.rawValue.toString();
	};
}

function numericFormatter() {
	var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
	var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '--';

	return function (metric) {
		if (metric.rawValue === undefined || metric.rawValue === null) {
			return defaultValue;
		}
		var value = Number(metric.rawValue) * factor;
		return precision === undefined ? value.toString() : value.toFixed(precision);
	};
}

/***/ }),

/***/ "./src/MetricService.js":
/*!******************************!*\
  !*** ./src/MetricService.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MetricService = exports.MetricService = function () {
	function MetricService(deviceInterface) {
		_classCallCheck(this, MetricService);

		this.deviceInterface = deviceInterface;
		this.metrics = {};
		this.bindings = [];
	}

	_createClass(MetricService, [{
		key: 'start',
		value: function start() {
			var ref = this;
			this.deviceInterface.onUpdate = function (key, value) {
				var metric = ref.metrics[key];
				if (metric !== undefined) {
					metric.rawValue = value;
					if (ref.onUpdate !== undefined) {
						ref.onUpdate(metric);
					}
				}
			};
			this.deviceInterface.onRawUpdate = function (path, value) {
				if (ref.onRawUpdate !== undefined) {
					ref.onRawUpdate(path, value);
				}
			};
			this.deviceInterface.connect();
		}
	}, {
		key: 'stop',
		value: function stop() {
			this.deviceInterface.disconnect();
		}
	}, {
		key: 'register',
		value: function register(key, path, description, unit, formatter) {
			var access = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'r';

			var metric = new Venus.Metric(key, description, unit, formatter);
			this.metrics[key] = metric;
			this.deviceInterface.register(key, path, access);
			return metric;
		}
	}, {
		key: 'unregister',
		value: function unregister(key) {
			this.metrics[key] = undefined;
			this.deviceInterface.unregister(key);
		}
	}, {
		key: 'bind',
		value: function bind(element) {
			var elementProperty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'innerHTML';
			var metricKey = arguments[2];
			var metricProperty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'value';

			var metric = this.metrics[metricKey];
			if (metric === undefined) {
				throw 'Binding failed. No registered metric ' + metricKey + ' was found.';
			}
			this.bindings.push(new Venus.DataBinding(element, elementProperty, metric, metricProperty));
		}
	}, {
		key: 'unbind',
		value: function unbind(element, elementProperty, metricKey, metricProperty) {
			this.bindings = this.bindings.filter(function (binding) {
				return binding.element !== element || binding.elementProperty !== elementProperty || binding.metric.key !== metricKey || binding.metricProperty !== metricProperty;
			});
		}
	}, {
		key: 'bindElements',
		value: function bindElements(element) {
			var ref = this;
			for (var i = 0; i < element.childNodes.length; i++) {
				var childNode = element.childNodes[i];
				if (childNode.attributes !== undefined) {
					var dataMetricAttribute = childNode.attributes['data-metric'];
					var dataMetricPropertyAttribute = childNode.attributes['data-metric-property'];
					var dataBindingAttribute = childNode.attributes['data-binding'];
					var dataBindingProperty = 'innerHTML';
					if (dataBindingAttribute !== undefined) {
						dataBindingProperty = dataBindingAttribute.nodeValue;
					}
					var dataMetricProperty = 'value';
					if (dataMetricPropertyAttribute !== undefined) {
						dataMetricProperty = dataMetricPropertyAttribute.nodeValue;
					}
					if (dataMetricAttribute !== undefined) {
						var metric = ref.metrics[dataMetricAttribute.nodeValue];
						if (metric !== undefined) {
							ref.bindings.push(new Venus.DataBinding(childNode, dataBindingProperty, metric, dataMetricProperty));
						} else {
							console.warn('Binding element failed. No registered metric ' + dataMetricAttribute.nodeValue + ' was found.');
						}
					}
				}
				ref.bindElements(childNode);
			}
		}
	}, {
		key: 'read',
		value: function read(key) {
			this.deviceInterface.read(key);
		}
	}, {
		key: 'write',
		value: function write(key, value) {
			this.deviceInterface.write(key, value);
		}
	}]);

	return MetricService;
}();

/***/ }),

/***/ "./src/MqttInterface.js":
/*!******************************!*\
  !*** ./src/MqttInterface.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// /** The MqttInterface class represents the transport layer
//     for the venus mqtt */

// The interface depends on the mqtt.js package for mqtt over websocket implementation
// todo: describe callbacks and usage
//       onError, onUpdate, onRawUpdate

var MqttInterface = exports.MqttInterface = function () {
	function MqttInterface() {
		var connection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'ws://localhost';

		_classCallCheck(this, MqttInterface);

		this.connection = connection;
		this.registeredPaths = {};
	}

	_createClass(MqttInterface, [{
		key: 'register',
		value: function register(key, path) {
			var access = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'r';

			if (!path.startsWith('/')) {
				path = '/' + path;
			}
			var lowerCaseAccess = access.toLowerCase();
			if (lowerCaseAccess !== 'r' && lowerCaseAccess !== 'w' && lowerCaseAccess !== 'rw') {
				throw 'Unallowed access ' + access;
			}
			this.registeredPaths[path] = new MqttInterfacePath(path, key, access);
		}
	}, {
		key: 'unregister',
		value: function unregister(key) {
			var path = this.lookupKey(key);
			if (path !== undefined) {
				this.registeredPaths[path.value] = undefined;
			}
		}
	}, {
		key: 'lookupKey',
		value: function lookupKey(key) {
			for (var pathValue in this.registeredPaths) {
				var path = this.registeredPaths[pathValue];
				if (path !== undefined && path.key === key) {
					return path;
				}
			}
		}
	}, {
		key: 'lookupPath',
		value: function lookupPath(path) {
			return this.registeredPaths[path];
		}
	}, {
		key: 'connect',
		value: function connect() {
			if (this.client !== undefined) {
				throw 'The mqtt interface is already connected';
			}
			this.portalId = undefined;
			this.clientId = new Date().toJSON().substring(2, 22);
			// todo: use config
			this.client = new Paho.MQTT.Client('192.168.3.82', 9001, this.clientId);
			var ref = this;

			this.client.onMessageArrived = function (message) {
				try {
					var topic = message.destinationName;
					if (ref.portalId === undefined) {
						// before the mqtt interface is ready to read or write
						// metric values it needs to detect its portal id. The 
						// venus device will publish a message on connect that is
						// used to extract the portal id.
						if (topic.startsWith('N/') && topic.endsWith('/system/0/Serial')) {
							var data = JSON.parse(message.payloadString);
							ref.portalId = data.value;
							console.log('portalId: ' + ref.portalId);
							for (var path in ref.registeredPaths) {
								// send read requests for all registered paths
								// to be able to update the ui with all values
								// quicker
								ref.client.send('R/' + ref.portalId + path, '');
							}
							ref.keepAlive();
						}
					} else {
						var prefixLength = ref.portalId.length + 2;
						if (topic.length > prefixLength) {
							var pathValue = topic.substring(prefixLength);
							var _path = ref.lookupPath(pathValue);
							var _data = JSON.parse(message.payloadString);
							if (ref.onUpdate !== undefined && _path !== undefined && _path.isReadable && _data.value !== undefined) {
								ref.onUpdate(_path.key, _data.value);
							}
							if (ref.onRawUpdate !== undefined) {
								ref.onRawUpdate(pathValue, _data.value);
							}
						}
					}
				} catch (error) {
					if (ref.onError !== undefined) {
						ref.onError(error);
					}
				}
			};

			this.client.connect({ onSuccess: function onSuccess(reconnect, uri) {
					ref.client.subscribe('N/#');
				} });
		}
	}, {
		key: 'disconnect',
		value: function disconnect() {
			if (this.client === undefined) {
				return;
			}
			this.client.disconnect();
			this.portalId = undefined;
			this.client.end();
		}
	}, {
		key: 'read',
		value: function read(key) {
			if (this.portalId === undefined) {
				throw 'Read failed. The mqtt interface has not detected its portal id yet';
			}
			var path = this.lookupKey(key);
			if (path === undefined) {
				throw 'Read failed. There is no path registered for key: ' + key;
			}
			if (!path.isReadable) {
				throw 'Read failed. The path with key ' + key + ' is not readable';
			}
			this.client.send('R/' + this.portalId + path.value, '');
		}
	}, {
		key: 'write',
		value: function write(key, value) {
			if (this.portalId === undefined) {
				throw 'Write failed. The mqtt interface has not detected its portal id yet';
			}
			var path = this.lookupKey(key);
			if (path === undefined) {
				throw 'Write failed. There is no path registered for key: ' + key;
			}
			if (!path.isWritable) {
				throw 'Write failed. The path with key ' + key + ' is not writable';
			}
			var data = JSON.stringify({ value: value });
			this.client.send('W/' + this.portalId + path.value, data);
		}
	}, {
		key: 'keepAlive',
		value: function keepAlive() {
			if (this.portalId === undefined) {
				return;
			}
			this.client.send('R/' + this.portalId + '/system/0/Serial', '');
		}
	}]);

	return MqttInterface;
}();

var MqttInterfacePath = exports.MqttInterfacePath = function MqttInterfacePath(path, key, access) {
	_classCallCheck(this, MqttInterfacePath);

	this.value = path;
	this.key = key;
	this.isReadable = access.toLowerCase().includes('r');
	this.isWritable = access.toLowerCase().includes('w');
};

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Metric = __webpack_require__(/*! ./Metric */ "./src/Metric.js");

Object.keys(_Metric).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Metric[key];
    }
  });
});

var _DataBinding = __webpack_require__(/*! ./DataBinding */ "./src/DataBinding.js");

Object.keys(_DataBinding).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _DataBinding[key];
    }
  });
});

var _MqttInterface = __webpack_require__(/*! ./MqttInterface */ "./src/MqttInterface.js");

Object.keys(_MqttInterface).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _MqttInterface[key];
    }
  });
});

var _MetricService = __webpack_require__(/*! ./MetricService */ "./src/MetricService.js");

Object.keys(_MetricService).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _MetricService[key];
    }
  });
});

var _Metric2 = __webpack_require__(/*! ./Metric.js */ "./src/Metric.js");

var _DataBinding2 = __webpack_require__(/*! ./DataBinding.js */ "./src/DataBinding.js");

var _DataBinding3 = _interopRequireDefault(_DataBinding2);

var _MqttInterface2 = __webpack_require__(/*! ./MqttInterface.js */ "./src/MqttInterface.js");

var _MqttInterface3 = _interopRequireDefault(_MqttInterface2);

var _MetricService2 = __webpack_require__(/*! ./MetricService.js */ "./src/MetricService.js");

var _MetricService3 = _interopRequireDefault(_MetricService2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ })

/******/ });
//# sourceMappingURL=venus-metrics.min.js.map